esphome:
  name: kotlownia
  on_boot:
  - state_machine.set: IDLE
  - switch.turn_off: stove_relay
  - switch.turn_off: wh_relay

esp32:
  board: esp32dev

#uart:
#  baud_rate: 115200
# Enable logging
logger:
  level: WARN

# Enable Home Assistant API
api:
  password: ""

ota:
  password: ""

packages:
  wifi: !include wifi.yaml

  

captive_portal:
#//
spi:
  clk_pin: GPIO18    #  sck 
  mosi_pin: GPIO23   #  mosi -> SDA(Serial DAta)
  
font:
  - file: "arial.ttf"
    id: arial
    size: 10 
  - file: "Consolas.ttf"
    id: consolas
    size: 10
color:
  - id: light_red
    red: 100%
    green: 20%
    blue: 25%
    white: 0%
  - id: light_green
    red: 0%
    green: 100%
    blue: 25%
    white: 0%
display:
  - platform: st7735
    model: "INITR_18BLACKTAB"
    cs_pin: GPIO21    #  D21->CS
    dc_pin: GPIO22    #  D5->A0  
    #reset_pin: D6 #  ->RESET
    rotation: 180
    device_width: 128
    device_height: 160
    col_start: 0
    row_start: 0
    eight_bit_color: true
    update_interval: 1s
    lambda: |-
      it.printf(0, 0, id(consolas),  "Stan: %s", id(current_state).c_str());
      it.printf(0, 9, id(consolas),  "Tryb: %s", id(mode).c_str());
      it.printf(0, 18, id(consolas), id(light_green), "------- Bufor --------");
      it.printf(0, 27, id(consolas), " %12s %.1f °C", "Gora:", id(buffer_temp_top).state);
      it.printf(0, 36, id(consolas), " %12s %.1f °C", "Dol:", id(buffer_temp_bottom).state);
      it.printf(0, 45, id(consolas), " %12s %.1f °C", "T docelowa:", id(buffer_temp_target).state);
      it.printf(0, 54, id(consolas), " %12s %.1f °C", "T minimalna:", id(buffer_temp_min).state);
      it.printf(0, 63, id(consolas), id(light_green), "-------- CWU ---------");
      it.printf(0, 72, id(consolas), " %12s %.1f °C", "Gora:", id(WH_temp_top).state);
      it.printf(0, 81, id(consolas), " %12s %.1f °C", "Dol:", id(WH_temp_bottom).state);
      it.printf(0, 90, id(consolas), " %12s %.1f °C", "T docelowa:", id(WH_temp_target).state);
      it.printf(0, 99, id(consolas), " %12s %.1f °C", "T minimalna:", id(WH_temp_min).state);
      it.printf(0, 108, id(consolas), " ");
      it.printf(0, 117, id(consolas), " %13s %s", "Kociol:", id(stove_relay).state==true?"ON":"OFF");
      it.printf(0, 126, id(consolas), " %13s %s", "Grzanie CWU:", id(wh_relay).state==true?"ON":"OFF");
      it.printf(0, 135, id(consolas), " %13s %s", "Pompa CWU:", true==true?"ON":"OFF");
      it.printf(0, 144, id(consolas), " %13s %u", "Test:", random(10));

globals:
  - id: current_state #maszyna stanów nie mam pola a'la opis, więc ta zmienna jest tylko po to, żeby wyświetlać stan maszyny "po polsku"
    type: std::string
    initial_value: '"INIT"'
  - id: mode
    type: std::string
    initial_value: '"LATO"'
  - id: top_up_active
    type: bool  
    initial_value: 'true'

external_components:
  - source: 
      type: git
      url: https://github.com/muxa/esphome-state-machine

state_machine:
  - name: "Maszyna stanów kotłowni"
    id: "sm1"
    initial_state: IDLE
    states: 
    - name: IDLE
      on_enter:
        - logger.log: 
            format: "Entering IDLE state"
            level: WARN
        - globals.set:
            id: current_state
            value: '"BEZCZYNNY"'
        - switch.turn_off: stove_relay
        - switch.turn_off: wh_relay
    - name: BUFFER_LOADING
      on_enter:
        - logger.log: 
            format: "Entering BUFFER_LOADING state"
            level: WARN
        - globals.set:
            id: current_state
            value: '"LADOWANIE BUFORA"'
        - switch.turn_on: stove_relay
        - switch.turn_off: wh_relay
    - name: BUFFER_FULL
      on_enter:
        - logger.log: 
            format: "Entering BUFFER_FULL state"
            level: WARN
        - globals.set:
            id: current_state
            value: '"BUFOR NAŁADOWANY"'
        - if:
            condition: # jeśli ustawiona jest flaga DOGRZEWANIE_CWU
              lambda: 'return id(top_up_active) == true;'
            then:
              - state_machine.transition: TOP_UP
            else:
              - state_machine.set: IDLE
    - name: WH_LOADING
      on_enter:
        - logger.log: 
            format: "Entering IDLE state"
            level: WARN
        - globals.set:
            id: current_state
            value: '"LADOWANIE ZASOBNIKA"'
        - lambda: |-
           id(current_state) = "GRZANIE CWU";
        - switch.turn_on: stove_relay
        - switch.turn_on: wh_relay
    - name: WH_FULL 
      # stan przejściowy w którym sprawdzamy, czy trzeba ładować bufor
      # w zasadzie możnaby ten stan pominąć i przejść od razu do IDLE po czym w razie potrzeby do BUFFER_LOADING ale mogłoby to spowodować chwilowe rozwarcie przekaźnika. 
      # Chuj wie, jak kocioł się zachowa
      on_enter:
        - logger.log: 
            format: "Entering WH_FULL state"
            level: WARN
        - lambda: |-
            id(current_state) = "ZASOBNIK PELNY";
        - if:
            condition:
              #- lambda: 'return id(buffer_temp_top).state < id(buffer_temp_min).state;'
              #debug
              - lambda: 'return id(buffer_temp_top_debug).state < id(buffer_temp_min).state;'
            then:
              - state_machine.set: BUFFER_LOADING
            else:
              - state_machine.set: IDLE 
    - name: WH_TOP_UP #dogrzewanie cwu. po naładowaniu bufora dogrzewamy zasobnik, żeby uniknąć niepotrzebnego wygaszania kotła
      on_enter:
        - logger.log: 
            format: "Entering WH_TOP_UP state"
            level: WARN
        - lambda: |-
            id(current_state) = "DOGRZEWANIE CWU";
        - if:
            condition: 
              - lambda: 'return 1;' #tymczasowo. Zmienić na jeżeli temperatura dołu zasobnika >= zadanej
            then:
              - state_machine.set: IDLE
            else:
              - switch.turn_on: stove_relay
              - switch.turn_on: wh_relay
    inputs:
      - name: WH_TEMP_BELOW_MIN
        transitions:
          - IDLE -> WH_LOADING
          - BUFFER_LOADING -> WH_LOADING
      - name: WH_TEMP_REACHED
        transitions:
          - WH_LOADING -> WH_FULL
          - WH_TOP_UP -> WH_FULL
      - name: BUFFER_TEMP_BELOW_MIN
        transitions:
          - IDLE -> BUFFER_LOADING
      - name: BUFFER_TEMP_REACHED
        transitions:
          - BUFFER_LOADING -> BUFFER_FULL
      - name: TOP_UP
        transitions:
          - BUFFER_FULL -> WH_LOADING
      - name: GO_IDLE
        transitions:
          - BUFFER_FULL -> IDLE
          
number:
  - platform: template
    name: "T. zadana bufora"
    id: buffer_temp_target
    restore_value: True
    initial_value: 75
    optimistic: True
    #min_value: 50
    min_value: 20
    max_value: 80
    step: 1
  - platform: template
    name: "T. minimalna bufora"
    id: "buffer_temp_min"
    optimistic: True
    restore_value: True
    initial_value: 35
    #min_value: 30
    min_value: 20
    max_value: 45
    step: 1
  - platform: template
    name: "T. zadana CWU"
    id: "WH_temp_target"
    restore_value: True
    initial_value: 45
    optimistic: True
    #min_value: 40
    min_value: 20
    max_value: 50
    step: 1 
  - platform: template
    name: "T. minimalna CWU"
    id: "WH_temp_min"
    optimistic: True
    restore_value: True
    initial_value: 35
    #min_value: 30
    min_value: 20
    max_value: 45
    step: 1
  # wszystko poniżej na potrzeby debugowania. ustawiam temperatuty ręcznie
  - platform: template
    name: "T.bufora góra"
    id: "buffer_temp_top_debug"
    optimistic: True
    initial_value: 35
    min_value: 20
    max_value: 85
    step: 1
  - platform: template
    name: "T.bufora dół"
    id: "buffer_temp_bottom_debug"
    optimistic: True
    initial_value: 35
    min_value: 20
    max_value: 85
    step: 1
  - platform: template
    name: "T. zasobnika góra"
    id: "WH_temp_top_debug"
    optimistic: True
    initial_value: 35
    min_value: 20
    max_value: 45
    step: 1
  - platform: template
    name: "T.zasobnika dól"
    id: "WH_temp_bottom_debug"
    optimistic: True
    initial_value: 35
    min_value: 20
    max_value: 45
    step: 1

dallas:
  - pin: GPIO19
    update_interval: 2s
  
sensor:
  - platform: dallas
    accuracy_decimals: 1
    index: 0
    name: "Bufor_gora"
    id: "buffer_temp_top"
    on_value:
      if:
        condition: # jeśli temperatura na górze BUFORA spadnie poniżej minimalnej
          #lambda: 'return id(buffer_temp_top).state < id(buffer_temp_min).state;'
          #debug
          lambda: 'return id(buffer_temp_top_debug).state < id(buffer_temp_min).state;'
        then:
          - state_machine.transition: BUFFER_TEMP_BELOW_MIN
  #####
  - platform: dallas
    accuracy_decimals: 1
    index: 1 
    name: "Bufor_dol"
    id: "buffer_temp_bottom"
    on_value:
      if:
        condition: # jeśli tempetatura na dole BUFORA osiognie temperaturę zadaną
          #lambda: 'return id(buffer_temp_bottom).state >= id(buffer_temp_target).state;'
          #debug
          lambda: 'return id(buffer_temp_bottom_debug).state >= id(buffer_temp_target).state;'
        then:
          - state_machine.transition: BUFFER_TEMP_REACHED
  - platform: dallas
    accuracy_decimals: 1
    index: 2 
    name: "CWU_dol"
    id: "WH_temp_bottom"
    on_value:
      if:
        condition: # jeśli tempetatura na dole ZASOBNIKA osiognie temperaturę zadaną
          #lambda: 'return id(WH_temp_bottom).state >= id(WH_temp_target).state;'
          #debug
          lambda: 'return id(WH_temp_bottom_debug).state >= id(WH_temp_target).state;'
        then:
          - state_machine.transition: WH_TEMP_REACHED
    
  - platform: dallas
    accuracy_decimals: 1
    index: 3 
    name: "CWU_gora"
    id: "WH_temp_top"
    on_value:
      if:
        condition: # jeśli temperatura na górze ZASOBNIKA spadnie poniżej minimalnej dla CWU
          #lambda: 'return id(WH_temp_top).state < id(WH_temp_min).state;'
          #debug
          lambda: 'return id(WH_temp_top_debug).state < id(WH_temp_min).state;'
        then: 
          - state_machine.transition: WH_TEMP_BELOW_MIN

switch:
  - platform: gpio
    pin: GPIO13
    name: "Włączanie kotła"
    id: stove_relay
    inverted: true
  - platform: gpio
    pin: GPIO14
    name: "Grzanie CWU"
    id: wh_relay #WH = water heater
    inverted: true
  - platform: gpio
    pin: GPIO27
    name: "Cyrkulacja CWU"
    id: hot_water_pump_relay
    inverted: true
  - platform: template
    name: "Tryb (Lato/Zima)"
    id: mode_switch
    turn_on_action: 
      - globals.set:
          id: mode
          value: '"ZIMA"'
      - switch.template.publish:
          id: mode_switch
          state: !lambda 'return true;'
    turn_off_action:
      - globals.set:
            id: mode
            value: '"LATO"'
      - switch.template.publish:
          id: mode_switch
          state: !lambda 'return false;'  
  - platform: template
    name: "Dogrzewanie CWU"
    id: top_up_switch
    turn_on_action: 
      - globals.set:
          id: top_up_active
          value: "true"
      - switch.template.publish:
          id: top_up_switch
          state: !lambda 'return true;'
    turn_off_action:
      - globals.set:
            id: top_up_active
            value: "false"
      - switch.template.publish:
          id: top_up_switch
          state: !lambda 'return false;'  